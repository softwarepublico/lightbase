/*
Copyright 1990-2008 Light Infocon Tecnologia S/A

Este arquivo é parte do programa LightBase - Banco de Dados Textual Documental

O LightBase é um software livre; você pode redistribui-lo e/ou modifica-lo dentro 
dos termos da Licença Pública Geral GNU como publicada pela Fundação do Software 
Livre (FSF); na versão 2 da Licença.

Este programa é distribuído na esperança que possa ser útil, mas SEM NENHUMA 
GARANTIA; sem uma garantia implícita de ADEQUAÇÃO a qualquer MERCADO ou APLICAÇÃO 
EM PARTICULAR. Veja a Licença Pública Geral GNU para maiores detalhes.

Você deve ter recebido uma cópia da Licença Pública Geral GNU versao 2, sob o título
"LICENCA.txt", junto com este programa, se não, escreva para a Fundação do Software 
Livre(FSF) Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
*/

//
//	Este modulo contem as funcoes mais chamadas pelo stub cliente
//
//

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>

#ifndef _SESSCL_H_
	#include <sesscl.h>
#endif	// _SESSCL_H_

#ifndef __lbsrpc_h__
	#include <lbsrpc.h>    // header file generated by MIDL compiler
#endif	// __lbsrpc_h__


/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/
#ifdef LBS_DLL
	extern 	RPC_SS_THREAD_HANDLE _pThreadHandle;
#endif

void  __RPC_FAR * __RPC_API 
MIDL_user_allocate(size_t len)
{
    return(	(void  __RPC_FAR * )new unsigned char[len] );
}

void __RPC_API 
MIDL_user_free(void __RPC_FAR * ptr)
{
    delete(ptr);
}


//
//	Libera memoria alocada pelo RPC no lado cliente;
//
void
ClntFree( void *pvPointer )
{
	if ( pvPointer ) {
#ifndef RPC_SOCK
		RpcSmFree(pvPointer);
#else
		delete pvPointer;
#endif
	}
}


TSRTicket 
BuildTickBuff( const LBSC_Ticket* ptTicket )
{
	TSRTicket sRet;
	if( ptTicket ){
		sRet.lTickLen = sizeof( LBSC_Ticket );
		sRet.szTickBuff = (unsigned char*)ptTicket;
	} else {
		sRet.lTickLen = 0;
		sRet.szTickBuff = NULL;
	}
	return( sRet );													  	
}

const LBSC_Ticket* 
BuildTicket( TSRTicket sTicket )
{
	LBSC_Ticket* Ret = new LBSC_Ticket;

	if( Ret && sTicket.szTickBuff ){
		memcpy( Ret, sTicket.szTickBuff, sizeof( LBSC_Ticket ));
		return( Ret );
	}

	if( Ret ){
		delete Ret;
	}
	return( NULL );
}


void
DeleteVect( char **pObj )
{
	if ( pObj ) {
		for ( int i=0; pObj[i] != NULL; i++) {
			delete pObj[i];
		}

		delete pObj;
	}
}


