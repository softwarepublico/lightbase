/*
Copyright 1990-2008 Light Infocon Tecnologia S/A

Este arquivo é parte do programa LightBase - Banco de Dados Textual Documental

O LightBase é um software livre; você pode redistribui-lo e/ou modifica-lo dentro 
dos termos da Licença Pública Geral GNU como publicada pela Fundação do Software 
Livre (FSF); na versão 2 da Licença.

Este programa é distribuído na esperança que possa ser útil, mas SEM NENHUMA 
GARANTIA; sem uma garantia implícita de ADEQUAÇÃO a qualquer MERCADO ou APLICAÇÃO 
EM PARTICULAR. Veja a Licença Pública Geral GNU para maiores detalhes.

Você deve ter recebido uma cópia da Licença Pública Geral GNU versao 2, sob o título
"LICENCA.txt", junto com este programa, se não, escreva para a Fundação do Software 
Livre(FSF) Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
*/

//
//	Este modulo contem as funcoes mais chamadas pelo stub cliente
//
//

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>

#ifndef _SESSCL_H_
	#include <sesscl.h>
#endif	// _SESSCL_H_

#ifndef __lbsrpc_h__
	#include <lbsrpc.h>    // header file generated by MIDL compiler
#endif	// __lbsrpc_h__

#ifndef _FBUFF_H
#include    <fbuff.h>
#endif


#define	NUM_MSECS_HOUR	3600000
#define	NUM_MSECS_MIN	60000
#define	NUM_MSECS_SEC	1000


/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void  __RPC_FAR * __RPC_API 
MIDL_user_allocate(size_t len)
{
    return(	(void  __RPC_FAR * )malloc(len) );
}

void __RPC_API 
MIDL_user_free(void __RPC_FAR * ptr)
{
	if ( ptr ) {
		free (ptr);
	}
}


//
//	Libera memoria alocada pelo RPC no lado cliente;
//
void
ClntFree( void *pvPointer )
{
	if ( pvPointer ) {
		free( pvPointer );
	}
}


TSRTicket 
BuildTickBuff( const LBSC_Ticket* ptTicket )
{
	TSRTicket sRet;
	if( ptTicket ){
		sRet.lTickLen = sizeof( LBSC_Ticket );
		sRet.szTickBuff = (unsigned char*)ptTicket;
	} else {
		sRet.lTickLen = 0;
		sRet.szTickBuff = NULL;
	}
	return( sRet );													  	
}

const LBSC_Ticket* 
BuildTicket( TSRTicket sTicket )
{
	LBSC_Ticket* Ret = new LBSC_Ticket;

	if( Ret && sTicket.szTickBuff ){
		memcpy( Ret, sTicket.szTickBuff, sizeof( LBSC_Ticket ));
		return( Ret );
	}

	if( Ret ){
		delete Ret;
	}
	return( NULL );
}


void
DeleteVect( char **pObj )
{
	if ( pObj ) {
		for ( int i=0; pObj[i] != NULL; i++) {
			delete pObj[i];
		}

		delete pObj;
	}
}


//
//	Faz o mesmo que o strdup so que aloca com new; como o strdup
//	usa malloc, um delete no ponteiro retornado pode detonar tudo
//
char *
StrDup( const char *szPar )
{
	if ( !szPar ) 
		return NULL;

	char *szRet = new char[strlen(szPar) + 1];

	if ( !szRet ) 
		return NULL;

	strcpy(szRet, szPar);

	return szRet;
}


void
Log( char *szPar )
{
#ifdef	_DEBUG

	if ( !szPar ) 
		return;


	char szFile[100] = "c:\\tmp\\LBWCli.txt";

	FILE *fp = fopen(szFile, "at");
	if ( !fp )
		return;

	char szMsg[500];
	DWORD	dwTime = GetTickCount();

	DWORD dwHour	= 
		dwTime / NUM_MSECS_HOUR;					// horas
	DWORD dwMin		= 
		(dwTime % NUM_MSECS_HOUR) / NUM_MSECS_MIN;	// minutos
	DWORD dwSec		=
		(dwTime % NUM_MSECS_MIN) / NUM_MSECS_SEC;	// segundos
	DWORD dwMSec	=
		(dwTime % NUM_MSECS_SEC);					// milesimos

	sprintf(szMsg, "%-35s\t%d:%d:%d:%02d \n", szPar, 
						dwHour, dwMin, dwSec, dwMSec/10);

	fwrite(szMsg, strlen(szMsg), 1, fp);

	fclose(fp);

#endif	// _DEBUG
}



/***
	Retorna uma lista COccurList contida no buffer.
***/
COccurList *
MakeOccurList( TSROut_GenericBuffer sBuff )
{
	COccurList	*pList = new COccurList;
	if ( !sBuff.lTamBuff || !pList ) {
		return NULL;
	}

	C_Buffer cBuff( sBuff.lTamBuff - sizeof(int) );	// pula o int do cbuffer; 

	cBuff.PutData( (void*) (sBuff.szBuffer + sizeof(int)), sBuff.lTamBuff - sizeof(int)); // pula o int do cbuffer; 
	cBuff.Rewind();

	int iStrLen=0;
	char *szTerm=NULL;
	long lRec=0;
	int iField=0;
	int iRep=0;
	int iPar=0;
	int iPhra=0;
	int iSeq=0;
	int iCurrIndex =0;

	// guarda era a posicao da lista no servidor
	if ( !cBuff.GetData( (void *)&iCurrIndex, sizeof(iCurrIndex)) ) {
		return NULL;
	}

	while ( cBuff.GetData( (void *)&iStrLen, sizeof(iStrLen)) ) {

		int iErrMask = 0;

		if ( iStrLen ) {
			szTerm = new char[iStrLen];
			if ( !szTerm ) {
				return NULL;
			}
			iErrMask |= !cBuff.GetData( (void*) szTerm, iStrLen );

		}
		else {
			szTerm = NULL;
		}

		iErrMask |= !cBuff.GetData( (void*) &lRec, sizeof(lRec));
		iErrMask |= !cBuff.GetData( (void*) &iField, sizeof(iField));
		iErrMask |= !cBuff.GetData( (void*) &iRep, sizeof(iRep));
		iErrMask |= !cBuff.GetData( (void*) &iPar, sizeof(iPar));
		iErrMask |= !cBuff.GetData( (void*) &iPhra, sizeof(iPhra));
		iErrMask |= !cBuff.GetData( (void*) &iSeq, sizeof(iSeq));

		if ( iErrMask != 0 ) {
			return NULL;
		}

		LBSC_Occurrence	*pOccur = new LBSC_Occurrence;
		if ( !pOccur ) {
			return NULL;
		}

		pOccur->Set( szTerm, lRec, iField, iRep, iPar, iPhra, iSeq );

		delete szTerm;

		COccurInfo *poiInfo = new COccurInfo (pOccur);

		pList->Add(poiInfo, TAIL);

	}

	(*pList)[iCurrIndex];	// posiciona correntamente na lista

	return( pList );
}

