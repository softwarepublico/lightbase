/*
Copyright 1990-2008 Light Infocon Tecnologia S/A

Este arquivo é parte do programa LightBase - Banco de Dados Textual Documental

O LightBase é um software livre; você pode redistribui-lo e/ou modifica-lo dentro 
dos termos da Licença Pública Geral GNU como publicada pela Fundação do Software 
Livre (FSF); na versão 2 da Licença.

Este programa é distribuído na esperança que possa ser útil, mas SEM NENHUMA 
GARANTIA; sem uma garantia implícita de ADEQUAÇÃO a qualquer MERCADO ou APLICAÇÃO 
EM PARTICULAR. Veja a Licença Pública Geral GNU para maiores detalhes.

Você deve ter recebido uma cópia da Licença Pública Geral GNU versao 2, sob o título
"LICENCA.txt", junto com este programa, se não, escreva para a Fundação do Software 
Livre(FSF) Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
*/

//
//	LADO CLIENTE
//

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <time.h>

#ifndef _CSTRTOK_H_
	#include	<cstrtok.h>  
#endif	// _CSTRTOK_H_

#ifndef _LBSDEFS_H_
	#include <lbsdefs.h>
#endif	// _LBSDEFS_H_

#ifndef _LBSNETCL_H_
	#include <lbsnetcl.h>
#endif	// _LBSNETCL_H_

#ifndef _LBSERRTB_H_
	#include <lbserrtb.h>
#endif	// _LBSERRTB_H_

#ifndef _GETSRVRS_H_
	#include <getsrvrs.h>
#endif	// _GETSRVRS_H_

#ifndef _APPMNGR_H_
	#include <appmngr.h>
#endif	// _APPMNGR_H_

#ifndef _ADMDEFS_H_
	#include <admdefs.h>
#endif	// _ADMDEFS_H_

#ifndef _SESSCL_H_
	#include <sesscl.h>
#endif	// _SESSCL_H_

#ifndef 	_VERSION_H_
	#include <version.h>
#endif

#include <clientconfig.h>
// so pra constar...
class COccurList;
class C_Buffer;

#ifndef _CLNTFUNCS_H_
	#include <clntfuncs.h>
#endif	// _CLNTFUNCS_H_

#ifndef _STUBCRIT_H_
	#include <stubcrit.h>
#endif	// _STUBCRIT_H_

#ifndef _GETNAME_H_
	#include <getname.h>
#endif	// _GETNAME_H_

#ifndef _IS32S_H_
	#include <is32s.h>
#endif	// _IS32S_H_

#ifndef __chkvers_h__
	#include <chkvers.h>    // header file generated by MIDL compiler 
#endif	// __chkvers_h__

#include <ntdsapi.h>

//
//	Variaveis globais
//
static char	_szNetErrDesc[MAXERRORMSGSIZE];	// descricao dos erros de rede
static C_SInfoList	*_pcsilServers = new C_SInfoList;	// lista de servidores 
extern AppParmsMngr	*_pcInter;	// para internacionalizacao
// qual o ultimo erro no stub? protegido pela regiao critica do handle RPC
static int	_iNetError = LBS_OK;	
static char	*szNetError = NULL;
extern RPC_CLIENT_INTERFACE lbsrpc___RpcClientInterface;

// callback para tratamento de erro de RPC
static LBSERRPROC _ErrorCallback = NULL;	

//	Inicializacao dos atributos estaticos da classe
char *LBSC_ClntNet::szAppName = StrDup("");
char *LBSC_ClntNet::szClientName = StrDup("");
long LBSC_ClntNet::lClntTimeStamp = 0;
char *LBSC_ClntNet::szReinstallPath = NULL;

    
//
//	Prototipos internos
//
void PreencheHandleInf( char *, char *, unsigned *, int, long *);
void RemoveQuotationMarks( char * );



void
SetErrorFunc( LBSERRPROC NewCallback ) 
{
	_ErrorCallback = NewCallback;
}

void FillErrorDesc( char *szSection, char *szDetail ) 
{
	char	*szErrAux = NULL;

	if ( !szSection ) {
		strcpy(_szNetErrDesc, "");
		return;
	}

	if( _pcInter->BuildStatus == CHECKISOK ){
		szErrAux = _pcInter->GetGenMsgsAppVar( szSection );
	} 
	if( szErrAux ){
		strncpy( _szNetErrDesc, szErrAux, MAXERRORMSGSIZE );
		delete szErrAux;
	} else {
		// deu pau na internacionalizacao. vamos retornar na porrada 
		strcpy(_szNetErrDesc, "Erro durante a comunicação com o servidor LBW" );
	}
	if ( szDetail && (strlen(_szNetErrDesc) + strlen(szDetail) + 3) < MAXERRORMSGSIZE ) {
		strcat( _szNetErrDesc, ": " );
		strcat( _szNetErrDesc, szDetail );
	}
}
 
LBSC_ClntNet::LBSC_ClntNet( )
{
    lSvcTimeStamp=0;
	strcpy(_szNetErrDesc, "");
}

LBSC_ClntNet::~LBSC_ClntNet( )
{
}

void
LBSC_ClntNet::SetClientInfo()
{
	if ( szAppName ) {
		delete szAppName;
	}
	if ( szClientName ) {
		delete szClientName;
	}

	//
	// obtendo o nome da aplicacao...
	//
	char szPath [ 255 + 1 ] = "";
	GetModuleFileName( NULL, szPath, 255 );

	RemoveQuotationMarks( szPath );	// se for Win95, o nome da aplicacao vem entre aspas

	int iBeginAppName=0;	// indice a partir do qual aparece o nome da aplicacao
	for ( int i = strlen(szPath); i > 0; i-- ) {
		if ( szPath[i] == '\\' ) {	// procura um contrabarra
			iBeginAppName = i+1;
			break;
		}
	}

	szAppName = StrDup( szPath + iBeginAppName );
	if ( !szAppName ) {
		szAppName = StrDup("");
	}


	//
	// obtendo o nome da maquina...
	//
	int iProto = 0;
	char **pszServers = NULL;
	int iTmOut=0;
	LBSC_Session::GetClientParam( &iProto, (int *)&iTmOut, NULL, NULL, 
						&pszServers );
	if ( pszServers ) {
		DeleteVect( pszServers );
	}

	char *szMachine = NULL;
	if ( Is32s() || iProto == LBSPROTO_TCPIP ) {
		szMachine = (char *)GetMachineName( TCPIP_PROTO );
	}
	else {
		szMachine = (char *)GetMachineName();
	}
	szClientName = szMachine ? StrDup(szMachine) : StrDup("");

	//
	// obtendo timestamp...
	//
	lClntTimeStamp = GetCurrentProcessId();
}


TSRClntInitInfo 
LBSC_ClntNet::ObtemInitInfo()
{
	TSRClntInitInfo sControlInit;
	memset(&sControlInit, 0, sizeof(sControlInit));

	strcpy((char *)sControlInit.szAppName, szAppName);
	strcpy((char *)sControlInit.szClientName, szClientName);
	sControlInit.lClntTimeStamp = lClntTimeStamp;

	return sControlInit;
}


const char *
LBSC_ClntNet::ObtemClientIniName()
{
	static char szPath [ 255 + 1 ];
	static BOOL bFirst = TRUE;
	static char szReturn[FULLNAMESIZE + 1] = "";

	if( bFirst ){
		HMODULE  hMod = GetModuleHandle( "LBS.DLL" ); 
		szPath [ 0 ] = '\0';
		GetModuleFileName( hMod, szPath, 255 );
		for( int i = strlen( szPath ) - 1; i >= 0; i-- ) {
		  if( szPath[ i ] == '\\' || szPath[ i ] == '/' ) {
			 szPath[ i ] = '\0';
			 break;
		  }
		}

		RemoveQuotationMarks( szPath );	// se for Win95, o nome da aplicacao vem entre aspas

		int iEndPath = strlen(szPath);

		// copia o caminho da aplicacao
		strncpy(szReturn, szPath, iEndPath );	

		szReturn[iEndPath] = '\\';	// poe o contrabarra

		// copia o nome do .INI
		strncpy(szReturn + iEndPath + 1, CLIENTINIFILE, strlen(CLIENTINIFILE) + 1);	

		bFirst = FALSE;
	}

	return szReturn;
}

void 
LBSC_ClntNet::SetTimeStamp( long NewTimeStamp )
{
	lSvcTimeStamp = NewTimeStamp;
}

int
LBSC_ClntNet::QualNetError( char *szServer )
{
	return ( _iNetError );
}

const char *
LBSC_ClntNet::GetNetErrorDesc()
{
	switch ( _iNetError ) {
	case LBSE_NETERROR:
		return _szNetErrDesc;
	}

	static char szDefErr[] = "";
	return szDefErr;
}


//
//	Testa se uma RPC bloquearia outra em andamento (so acontece em socket)
//
boolean 
LBSC_ClntNet::RPCWouldBlock()
{

#ifdef RPC_SOCK
	return Sock->IsUsingSock();
#else
	return FALSE;
#endif
}


boolean 
LBSC_ClntNet::GetRPCHandle( char *szServer )
{
	if ( !szServer ) {
		return FALSE;
	}

	if ( stricmp(szServer, "") == 0 ) {
		return FALSE;
	}

	ServerInfo	*psiFindItem = new ServerInfo(szServer);
	ServerInfo	*psiItem = NULL;

	////////////////////////////////////////////////
	// entra na regiao critica da lista de servidores
	C_CritSecManager cProtectList ( SECTIONID_1 );
	////////////////////////////////////////////////

	_pcsilServers->First();
	if ( (psiItem = _pcsilServers->Find(psiFindItem, TRUE )) != NULL ) {	
		// ja temos informacao deste servidor (handle);
		// podemos atribuir ao handle global o handle desse servidor

		SetHandleValue( psiItem );
		_iNetError = LBS_OK;
		FillErrorDesc( NULL, NULL );
		delete psiFindItem;

		return TRUE;
	}
	delete psiFindItem;

	int iNumRetries=0;
	BOOL bRet = FALSE;
	//	fica num loop tentando varios endpoints (portas) ate
	//	conseguir um que seja o servidor LightBase ou
	//	cujo servidor nao responda
	long lPort=0;
	GetServerPort( szServer, &lPort );
	unsigned long ulErr=0;
	do {
		// tentamos varios endpoints (portas), mas so ate um 
		// numero maximo de vezes
		if ( iNumRetries > MAXATTACHRETRIES ) {
			_iNetError = LBSE_NETERROR;
			FillErrorDesc( "LBCLIENTMSG_NETERROR", NULL );
			break;
		}

		if ( !GetHandle( szServer, &lPort, iNumRetries ) ) {
			_iNetError = LBSE_NETERROR;
			break;
			// descricao do erro ja foi preenchida
		}
		if ( !GetHandle( szServer, &lPort, 0 ) ) {
			_iNetError = LBSE_NETERROR;
			break;
			// descricao do erro ja foi preenchida
		}

		RpcTryExcept{
			RPC_SvcIsUp();
			bRet = TRUE;

			if ( MustReinstal() ) {	// forcando a verificacao de versao da interface
				_iNetError = LBSE_REINSTALL;
				break;
			}

			break;
		}
		RpcExcept(1){	// erro de RPC 
			unsigned long uRet = RpcExceptionCode();
			if ( uRet == RPC_S_UNKNOWN_IF ) { 
				// versoes incompativeis entre cliente e servidor

				if ( MustReinstal() ) { // evitando a verificacao de versao da interface
					_iNetError = LBSE_REINSTALL;
					break;
				}

				_iNetError = LBSE_NETERROR;
				FillErrorDesc( "LBCLIENTMSG_VERSIONERROR", NULL );
				break;
			}
			if ( uRet != RPC_S_SERVER_UNAVAILABLE ) {
				char szAux[100];
				sprintf( szAux, "%d", uRet );
				_iNetError = LBSE_NETERROR;
				FillErrorDesc( "LBCLIENTMSG_NETERROR", szAux );
				break;
			}
		}
		RpcEndExcept

		iNumRetries++;
	} while ( !bRet );

	if ( !bRet ) {
		return FALSE;
	}

	// o handle do novo servidor eh o obtido no GetHandle 
	// podemos incluir este servidor na lista de servidores ativos
	psiItem = new ServerInfo( szServer, _lbsrpc_IfHandle, _chkvers_IfHandle );

		if ( psiItem ) {
			_pcsilServers->Add(psiItem, TAIL);
		}

	// podemos guardar essa porta para futuras conexoes com esse servidor;
	// o valor usado eh a propria porta ou ela mais uma potencia de 2
	SetServerPort( szServer, lPort  );

	_iNetError = LBS_OK;
	FillErrorDesc( NULL, NULL );
    return( TRUE );
}

boolean
LBSC_ClntNet::EnviaNovaRPC()
{
	if ( !_ErrorCallback )
		return FALSE;

	return ( _ErrorCallback() == RPC_RETRY );
}

void
LBSC_ClntNet::TrataErroRPC( char *szServer, unsigned long ulException )
{
	if ( ulException == RPC_S_INVALID_ARG ) {
		return;
	}

	// vamos ver se o handle rpc atual precisa realmente ser recriado 
	RpcTryExcept{
		RPC_SvcIsUp();
		// se chegou aqui, nao precisamos detona-lo
		return;
	}
	RpcExcept(1){	// erro de RPC 
		unsigned long uRet = RpcExceptionCode();
	}
	RpcEndExcept

	////////////////////////////////////////////////
	// entrar na regiao critica da lista de servidores
	C_CritSecManager cProtectList( SECTIONID_1 );
	////////////////////////////////////////////////

		_iNetError = LBSE_NETERROR;
		FillErrorDesc( "LBCLIENTMSG_NETERROR", NULL );
		ServerInfo	siFindItem(szServer);
		ServerInfo	*psiItem = NULL;
		_pcsilServers->First();
		if ( (psiItem = _pcsilServers->Find(&siFindItem, TRUE )) != NULL ) {	
			// a informacao deste servidor deve ser eliminada, mas os handles nao devem ser destruidos.. 
			// pode haver outras rpcs pendentes... so vamos remover da lista;
			psiItem->RpcHandle = NULL;
			psiItem->RpcHandleChkVers = NULL;
			_pcsilServers->Del();	
		}
}

void 
LBSC_ClntNet::SetHandleValue( ServerInfo *psiNew )
{
	if ( !psiNew ) {
		return;
	}
	_lbsrpc_IfHandle = psiNew->RpcHandle;	
	_chkvers_IfHandle = psiNew->RpcHandleChkVers;	
}


void
LBSC_ClntNet::FreeRPCHandle()
{
	// nada a fazer... mantida apenas por compatibilidade
}

//
//	Obtem os handles da forma particular de cada tipo de RPC(socket ou DCE)
//
boolean
LBSC_ClntNet::GetHandle( char *szServer, long *plPort, int iNumRetries )
{
#ifdef RPC_SOCK

	struct timeval	TmOut;

	TmOut.tv_sec = 0 ;		
	TmOut.tv_usec = 0;

	Sock = new LbsSock( TmOut );
	if ( !Sock->CriaSock( 0 ) ) {
		return FALSE;
	}

	*plPort = iNumRetries == 0 ? *plPort : 
				*plPort + LBSDELTA_PORT;
	if ( *plPort < LBSDEFPORT_TCPIP || *plPort > LBSMAXPORT_TCPIP ) {
		*plPort = LBSDEFPORT_TCPIP;
	}

	return ( Sock->ConectaRemoto( szServer, *plPort ) );

#else    // RPC_SOCK
	char   szProtocolSequence[100];
	char   szEndpoint[100];
	char   *pszUUIDlbsrpc = "9725e2c0-72c5-11cf-98a2-444553540000";
	char   *pszUUIDchqvers = "98f1c230-9eb3-11d3-91ad-006097d328e5";

	unsigned iTmOut;

	PreencheHandleInf(	szProtocolSequence, szEndpoint, 
						&iTmOut, iNumRetries, plPort);

	// gera o binding para a interface lbsrpc
	if ( !MakeBinding( pszUUIDlbsrpc, szProtocolSequence, szServer, szEndpoint, &_lbsrpc_IfHandle) ) {
		return FALSE;
	}
    RpcMgmtSetComTimeout(_lbsrpc_IfHandle, iTmOut);

	// gera o binding para a interface chkvers
	if ( !MakeBinding( pszUUIDchqvers, szProtocolSequence, szServer, szEndpoint, &_chkvers_IfHandle) ) {
	  	RpcBindingFree( &_lbsrpc_IfHandle );
		return FALSE;
	}
    RpcMgmtSetComTimeout(_chkvers_IfHandle, iTmOut);

	return TRUE;

#endif	// RPC_SOCK
}

boolean
LBSC_ClntNet::MakeBinding( const char *szUUID, const char *szProtocolSequence, 
						const char *szServer, const char *szEndPoint, RPC_HANDLE *handle )
{
	if ( !szUUID || !szProtocolSequence || !szServer || !szEndPoint ) {
		return FALSE;
	}
	unsigned char *szStringBinding = NULL;
	RPC_STATUS status = RPC_S_OK;
	char szAux[100];

    status = RpcStringBindingCompose((unsigned char	*)szUUID,
                                     ( unsigned char * )szProtocolSequence,
                                     ( unsigned char * )szServer,
                                     ( unsigned char * )szEndPoint,
                                     NULL,
                                     ( unsigned char ** )(&szStringBinding));
    if (status) {
        return(FALSE);
    }

    status = RpcBindingFromStringBinding(szStringBinding,
                           (RPC_BINDING_HANDLE * )handle);

	RpcStringFree(&szStringBinding);  
    if (status) {
        return(FALSE);
    }
	if ( !LBSC_ClientConfig::UseAuthentication() ) {
        return(TRUE);
	}

	DWORD SpnLength=0;
	char *pszSpn = NULL;
	char *szTryServer = (char *)szServer;

	DWORD dwStatus = DsMakeSpn( 
		"ldap",
		szTryServer,
		NULL,
		0,
		NULL,
		&SpnLength,
		NULL );

	if ( dwStatus == ERROR_INVALID_PARAMETER && !isalpha(szTryServer[0]) ) {	
		// vamos ver se eh um endereco IP
		unsigned long uAddr = inet_addr(szTryServer);
		if ( uAddr == INADDR_NONE ) {
			return(FALSE);
		}
		hostent *remoteHost = gethostbyaddr((char *) &uAddr, 4, AF_INET);
		if ( WSAGetLastError() != 0 ) {
			return(FALSE);
		}
		int iSize = strlen(remoteHost->h_name) + 1;
		szTryServer = new char[iSize + 10];
		strncpy( szTryServer, remoteHost->h_name, iSize);
		SpnLength = 0;
		dwStatus = DsMakeSpn( 
			"ldap",
			szTryServer,
			NULL,
			0,
			NULL,
			&SpnLength,
			NULL );
	}

	if ( SpnLength <= 0 || dwStatus != ERROR_BUFFER_OVERFLOW ) {
		sprintf( szAux, "%d", dwStatus );
		FillErrorDesc( "LBCLIENTMSG_PRINCIPALNAMEERROR", szAux );
		return(FALSE);
	}
	pszSpn = new char [SpnLength + 1];

	dwStatus = DsMakeSpn( 
		"ldap",
		szTryServer,
		NULL,
		0,
		NULL,
		&SpnLength,
		pszSpn );
	if ( szTryServer != szServer ) {
		delete szTryServer;
	}
	if ( dwStatus != ERROR_SUCCESS ) {
		sprintf( szAux, "%d", dwStatus );
		FillErrorDesc( "LBCLIENTMSG_PRINCIPALNAMEERROR", szAux );
		delete pszSpn;
        return(FALSE);
	}

	status = RpcBindingSetAuthInfo(
		*handle,                       // Valid binding handle
		(unsigned char *)pszSpn,                           // Principal name 
		RPC_C_AUTHN_LEVEL_DEFAULT,  // Authentication level
		RPC_C_AUTHN_DEFAULT,        // Use Negotiate SSP
		NULL,                             // Authentication credentials – use current thread credentials
		RPC_C_AUTHZ_NONE);                // Authorization service	return ( status == RPC_S_OK );

	delete pszSpn;

	if ( status != RPC_S_OK ) {
		sprintf( szAux, "%d", status );
		FillErrorDesc( "LBCLIENTMSG_AUTHERROR", szAux );
        return(FALSE);
	}

	return ( TRUE );
}


//
//	Se o servidor tiver referenciado por uma porta no .INI retorna 
//	a porta em plPort, senao retorna 0
//
void
LBSC_ClntNet::GetServerPort( char *szServer, long *plPort )
{
	char **pszServers=NULL;

	LBSC_Session::ObtemServidores( &pszServers );
	if ( !pszServers ) {
		return;
	}

	*plPort = 0;
	for (int i=0; pszServers[i] != NULL; i++) {
		char szHostInfo[100];
		C_StrTok	cstNewTok;

		strcpy( szHostInfo, pszServers[i]);
		// a porta eh separada por virgula
		char *szHost = cstNewTok.StrTok(szHostInfo, DELIMSERV_SET);
		if ( !szHost ) 
			szHost = szHostInfo;

		if ( stricmp( szHost, szServer ) == 0 ) {
			char *szPort = cstNewTok.StrTok(NULL, DELIMSERV_SET);
			if ( szPort ) {
				*plPort = atoi( szPort );
			}
			break;
		}	
	}	

	DeleteVect( pszServers );
}


void
LBSC_ClntNet::SetServerPort( char *szServer, long lPort )
{
	char **pszServers=NULL;

	if ( !szServer )  {
		return;
	}

	LBSC_Session::ObtemServidores( &pszServers );
	if ( !pszServers ) {
		return;
	}

	for (int i=0; pszServers[i] != NULL; i++) {
		char szHostInfo[100];
		C_StrTok	cstNewTok;

		strcpy( szHostInfo, pszServers[i]);
		// a porta eh separada por virgula
		char *szHost = cstNewTok.StrTok(szHostInfo, DELIMSERV_SET);
		if ( !szHost ) 
			szHost = szHostInfo;

		if ( stricmp( szHost, szServer ) == 0 ) {
			// substitui por outro par "maquina,porta"
			delete pszServers[i];
			if ( lPort ) {
				pszServers[i] = new char[strlen(szServer) + 20];
				sprintf(pszServers[i], "%s,%d", szServer, lPort);
			}
			else {
				pszServers[i] = StrDup(szServer);
			}

			LBSC_Session::AlteraServidores( pszServers );
			break;
		}
	}
	
	DeleteVect( pszServers );
}



//
//	Libera a lista de servidores
//
void
LBSC_ClntNet::LiberaServList()
{
	////////////////////////////////////////////////
	// entra na regiao critica da lista de servidores
	C_CritSecManager cProtectList( SECTIONID_1 );
	////////////////////////////////////////////////

	if ( _pcsilServers ) {
		_pcsilServers->DelAll();
	}
}


//
//	Retorna o número de sessoes abertas para szServer
//
int 
LBSC_ClntNet::OpenSessions( char *szServer )
{
	////////////////////////////////////////////////
	// entra na regiao critica da lista de servidores
	C_CritSecManager cProtectList( SECTIONID_1 );
	////////////////////////////////////////////////

		ServerInfo	siFindItem((char *)szServer);
		ServerInfo	*psiItem = NULL;
							
		_pcsilServers->First();
		if ( (psiItem = _pcsilServers->Find(&siFindItem, TRUE )) != NULL ) {	
			return (psiItem->iOpenSessions);
		}
		else {
			return 0;
		}
}

//
//	Incrementa o número de sessoes abertas para szServer
//
void 
LBSC_ClntNet::IncOpenSessions( char *szServer )
{
	////////////////////////////////////////////////
	// entra na regiao critica da lista de servidores
	C_CritSecManager cProtectList( SECTIONID_1 );
	////////////////////////////////////////////////

		ServerInfo	siFindItem((char *)szServer);
		ServerInfo	*psiItem = NULL;
							
		_pcsilServers->First();
		if ( (psiItem = _pcsilServers->Find(&siFindItem, TRUE )) != NULL ) {	
			psiItem->iOpenSessions++;
		}
}

//
//	Decrementa o número de sessoes abertas para szServer
//
void 
LBSC_ClntNet::DecOpenSessions( char *szServer )
{
	////////////////////////////////////////////////
	// entra na regiao critica da lista de servidores
	C_CritSecManager cProtectList( SECTIONID_1 );
	////////////////////////////////////////////////

		ServerInfo	siFindItem((char *)szServer);
		ServerInfo	*psiItem = NULL;
							
		_pcsilServers->First();
		if ( (psiItem = _pcsilServers->Find(&siFindItem, TRUE )) != NULL ) {	
			psiItem->iOpenSessions =	psiItem->iOpenSessions ? 
										psiItem->iOpenSessions-1 : 0;
		}
}



//
//	Esta funcao faz um verificacao das interfaces RPC para 
//	saber se eh necessario uma reinstalacao do produto
//
boolean
LBSC_ClntNet::MustReinstal() 
{
	// vamos primeiro verificar se as versoes do RPC do cliente e do servidor estao diferentes 

	// pega a interface cliente usada para todas as RPCs LBW
	// agora vamos decidir se realmente devemos exigir a reinstalacao
	// pra isso, pergunte ao servidor via outra interface RPC
	char *szRet = NULL;

	RpcTryExcept{
		szRet = (char *)RPC_MustReinstall();
	}
	RpcExcept(1){	// erro de RPC 
		//deu pau; fazer o que?...
		return FALSE;
	}
	RpcEndExcept

	if ( !szRet ) {
		return FALSE;
	}

	if ( szReinstallPath ) {
		delete szReinstallPath;
	}
	szReinstallPath = new char[strlen(szRet) + 1];
	strcpy( szReinstallPath, szRet );
	ClntFree( szRet );	// detona memoria do RPC

	// pra ter certeza de que temos que reinstalar, vamos ver se tem alguma 
	// restricao quanto aa versao que deve ser instalada

	char *szMinVers = NULL;

	RpcTryExcept{
		szMinVers = (char *)RPC_GetMinClientVersion();
	}
	RpcExcept(1){	// erro de RPC 
		//deu pau; fazer o que?...
		return FALSE;
	}
	RpcEndExcept

	if ( !szMinVers ) {
		// na duvida... nao vamos reinstalar
		return FALSE;
	}

	char szMyVersion[20];
	strcpy( szMyVersion, LBWAPPVERSION );
	C_StrTok	cstMyVers;
	char *szMyDigit = cstMyVers.StrTok( szMyVersion, "." );

	C_StrTok	cstMinVers;
	char *szMinDigit = cstMinVers.StrTok( szMinVers, "." );

	BOOL bReinstall = FALSE;

	while ( szMinDigit ) {
		int iMinDigit = atoi(szMinDigit);
		int iMyDigit = szMyDigit ? atoi(szMyDigit) : 0;
		if ( iMyDigit < iMinDigit ) {	// a copia atual eh mais velha
			bReinstall = TRUE;
			break;
		}
		if ( iMyDigit > iMinDigit ) {	// a copia atual eh mais nova
			break;
		}
		szMinDigit = cstMinVers.StrTok( NULL, "." );
		szMyDigit = szMyDigit ? cstMyVers.StrTok( NULL, "." ) : NULL;
	}

	ClntFree( szMinVers );	// detona memoria do RPC
	return bReinstall;
}


void
LBSC_ClntNet::CleanUp()
{
	if ( szAppName ) {
		delete szAppName;
		szAppName = NULL;
	}
	if ( szClientName ) {
		delete szClientName;
		szClientName = NULL;
	}
	if ( szReinstallPath ) {
		delete szReinstallPath;
		szReinstallPath = NULL;
	}
	if ( _pcsilServers ) {
		delete _pcsilServers;	
		_pcsilServers = NULL;
	}
	if ( _pcInter ) {
		delete _pcInter;
		_pcInter = NULL;
	}
}

void
PreencheHandleInf( char *szProto, char *szEndPoint, unsigned *pTmOut, 
				  int iNumRetries, long *plPort )
{
	int iProto, iTmOut;
	char **pszServers=NULL;

	LBSC_Session::GetClientParam( &iProto, (int *)&iTmOut, NULL, NULL, 
					&pszServers );

	long lMinPort=0;
	long lMaxPort=0;
	switch( iProto ) {
	case LBSPROTO_TCPIP:
		lMinPort=LBSDEFPORT_TCPIP;
		lMaxPort=LBSMAXPORT_TCPIP;
		strcpy(szProto, TCPIP_PROTO);
		break;

	case LBSPROTO_NETBEUI:
		lMinPort=LBSDEFPORT_NETBEUI;
		lMaxPort=LBSMAXPORT_NETBEUI;
		strcpy(szProto, NB_PROTO);
		break;

	case LBSPROTO_NAMEDPIPE:
		strcpy(szEndPoint, NP_ENDPOINT);
		strcpy(szProto, NP_PROTO);
		break;

	default:	// assumimos NETBEUI
		iProto = LBSDEFPORT_NETBEUI;
		lMinPort=LBSDEFPORT_NETBEUI;
		lMaxPort=LBSMAXPORT_NETBEUI;
		strcpy(szProto, NB_PROTO);
		LBSC_Session::SetClientParam( LBSPROTO_NETBEUI, LBS_CS_MED_TIMEOUT, 
							0, 0, pszServers);
	}

	if ( iProto != LBSPROTO_NAMEDPIPE ) {	
		// nao tem tratamento de porta em NAMEDPIPES
		*plPort = iNumRetries == 0 ? *plPort : 
					*plPort + LBSDELTA_PORT;

		if ( *plPort < lMinPort || *plPort > lMaxPort ) {
			*plPort = lMinPort;
		}
		sprintf(szEndPoint, "%d", *plPort);
	}

	switch ( iTmOut ) {
	case LBS_CS_LOW_TIMEOUT:
		*pTmOut = RPC_C_BINDING_MIN_TIMEOUT;
		break;

	case LBS_CS_MED_TIMEOUT:
		*pTmOut = RPC_C_BINDING_DEFAULT_TIMEOUT;
		break;

	case LBS_CS_HIGH_TIMEOUT:
		*pTmOut = RPC_C_BINDING_MAX_TIMEOUT;
		break;

	case LBS_CS_INF_TIMEOUT:
		*pTmOut = RPC_C_BINDING_INFINITE_TIMEOUT;
		break;

	default:
		*pTmOut = RPC_C_BINDING_DEFAULT_TIMEOUT;
	}

	DeleteVect( pszServers );
}


//
//	Retira aspas
//
void
RemoveQuotationMarks( char *szFilePath )
{
	if ( !szFilePath )
		return;

	char *szCopy;

	szCopy = szFilePath;
	while ( *szFilePath ) {
		if ( *szFilePath != '\"' ) {
			*szCopy++ = *szFilePath;
		}
		szFilePath++;
	}

	*szCopy = '\0';	//  copia o '\0'
}


ServerInfo::ServerInfo( char *szS, RPC_HANDLE NewHandle, RPC_HANDLE NewHandleChqVers )
{
    szServer = StrDup( szS );
    RpcHandle = NewHandle;
    RpcHandleChkVers = NewHandleChqVers;
	iOpenSessions = 0;
}

ServerInfo::~ServerInfo( void )
{
    if( szServer ){
    	delete szServer;
    }

    if ( RpcHandle ) {
		
		#ifdef RPC_SOCK
			delete RpcHandle;
		#else
	  		RpcBindingFree( &RpcHandle );
		#endif

    }
    if ( RpcHandleChkVers ) {
		
		#ifdef RPC_SOCK
			delete RpcHandle;
		#else
	  		RpcBindingFree( &RpcHandleChkVers );
		#endif
    }
}

int 
ServerInfo::Compare( ServerInfo *siOther, int )
{
	if ( !szServer || !siOther->szServer ) {
		return 1;
	}

    return stricmp(siOther->szServer, szServer);
}

ServerInfo *
ServerInfo::Duplicate( void )
{
    return NULL;
}



